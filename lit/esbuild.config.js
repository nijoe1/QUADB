import * as esbuild from "esbuild";
import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";

// Get current file directory
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
console.log(`📂 esbuild.config.js directory: ${__dirname}`);

// Parse command line arguments
const args = process.argv.slice(2);
const outfileArg = args.find((arg) => arg.startsWith("--outfile="));
const tsPathArg = args.find((arg) => arg.startsWith("--ts-path="));

if (!outfileArg) {
  console.error("❌ Error: --outfile argument is required");
  process.exit(1);
}

const outputPath = outfileArg.split("=")[1];
const tsPath = tsPathArg ? tsPathArg.split("=")[1] : null;

// Log directory contents
try {
  console.log(`📂 Working directory: ${process.cwd()}`);
  console.log(
    `📂 Working directory contents: ${fs.readdirSync(process.cwd()).join(", ")}`
  );
  console.log(`📂 Script directory: ${__dirname}`);
  console.log(
    `📂 Script directory contents: ${fs.readdirSync(__dirname).join(", ")}`
  );
} catch (error) {
  console.error(`Error listing directories: ${error.message}`);
}

// Determine the entry point
const entryPoint =
  tsPath || path.join(__dirname, "src", "lit-actions", "thresholdRecovery.ts");

console.log("📦 Build Configuration:");
console.log(`   Environment: ${process.env.VERCEL ? "Vercel" : "Local"}`);
console.log(`   Output Path: ${outputPath}`);
console.log(`   Entry Point: ${entryPoint}`);

// Verify the entry point exists
if (!fs.existsSync(entryPoint)) {
  console.error(`❌ Error: TypeScript file not found at ${entryPoint}`);
  process.exit(1);
}

// Read the content and extract the comment block
const content = fs.readFileSync(entryPoint, "utf8");
const commentBlock = content.match(/\/\*\*([\s\S]*?)\*\//)?.[1];

let injectedValues = [];
if (commentBlock) {
  // Find all lines containing 'inject' or 'inject:'
  const injectLines = commentBlock
    .split("\n")
    .filter((line) => line.includes("inject"));

  // Extract the injected values
  injectedValues = injectLines.map((line) => {
    const match = line.match(/inject:?\s*([^\s]+)/);
    return match ? match[1] : null;
  });

  // for each injected value, check if the file exist
  injectedValues.forEach((injectedValue) => {
    if (injectedValue && !fs.existsSync(injectedValue)) {
      throw new Error(`❌ File ${injectedValue} does not exist`);
    }
  });
}

const wrapIIFEInStringPlugin = {
  name: "wrap-iife-in-string",
  setup(build) {
    // Ensure write is set to false so our plugin will always receive outputFiles
    build.initialOptions.write = false;

    build.onEnd((result) => {
      if (result.errors.length > 0) {
        console.error("Build failed with errors:", result.errors);
        return;
      }

      result.outputFiles.forEach((outputFile) => {
        let content = outputFile.text.toString();

        // Process the file content to ensure it doesn't use imports
        content = content.replace(
          /import\s+.*?from\s+['"].*?['"]/g,
          "// Import removed"
        );
        content = content.replace(/export\s+\{.*?\}/g, "// Export removed");

        // Leaving this in for now, but not needed if we find a better
        // solution for the global ethers object.
        // IMPORTANT: if minify is disabled, we need to:
        // 1. remove var import_ethers = __require("ethers");
        // 2. remove import_ethers.
        content = content
          .replace(/var import_ethers = __require\("ethers"\);/g, "")
          .replace(/import_ethers\./g, "");

        // IMPORTANT: if minify is enabled, we need to:
        // 1. remove var t=o(\"ethers\");
        // 2. replace t.ethers to ethers
        content = content
          .replace(/var\s+\w+=\w+\("ethers"\);/g, "")
          .replace(/[a-zA-Z]\.ethers/g, "ethers");

        // Use JSON.stringify to safely encode the content
        const wrappedContent = `/**
 * DO NOT EDIT THIS FILE. IT IS GENERATED ON BUILD. RUN \`yarn generate-lit-actions\` IN THE ROOT DIRECTORY TO UPDATE THIS FILE.
 * 
 * @type { string } code - Lit Action code. You want to use the content in the "code" constant and NOT the content of this file.
 * 
 */
export const code = ${JSON.stringify(content, null, 2)};
`;

        // Ensure the output directory exists
        const dirname = path.dirname(outputPath);
        if (!fs.existsSync(dirname)) {
          fs.mkdirSync(dirname, { recursive: true });
        }

        // Write the file
        fs.writeFileSync(outputPath, wrappedContent);
        console.log(`📝 Writing to ${outputPath}`);
      });
    });
  },
};

// Resolve the path to esbuild-shims.js
const shimsPath = path.join(__dirname, "esbuild-shims.js");
if (!fs.existsSync(shimsPath)) {
  console.error(`❌ Error: esbuild-shims.js not found at ${shimsPath}`);
  process.exit(1);
}

// Build configuration
const buildConfig = {
  entryPoints: [entryPoint],
  bundle: true,
  write: false,
  platform: "browser",
  format: "esm",
  target: "es2020",
  minify: false,
  treeShaking: true,
  plugins: [wrapIIFEInStringPlugin],
  external: ["ethers"],
  inject: [shimsPath],
  banner: {
    js: "// @ts-nocheck\n// Bundled Lit Action\n",
  },
};

console.log(`🔧 Build format: ${buildConfig.format}`);

// Execute the build
esbuild
  .build(buildConfig)
  .then(() => {
    console.log("✅ Build completed successfully");
    console.log(`   Output file: ${outputPath}`);
  })
  .catch((error) => {
    console.error("❌ Build failed:", error);
    process.exit(1);
  });
